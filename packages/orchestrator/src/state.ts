import type { BaseMessage } from "@langchain/core/messages";
import { Annotation, messagesStateReducer } from "@langchain/langgraph";
import { z } from "zod";
import type { ModelTokenData, TaskPlan } from "./types.js";

/**
 * Token data reducer for merging token usage across multiple LLM calls
 * Follows the pattern from Open SWE's tokenDataReducer
 */
export function tokenDataReducer(
  state: ModelTokenData[] | undefined,
  update: ModelTokenData[],
): ModelTokenData[] {
  if (!state) {
    return update;
  }

  // Create a map to merge data by model
  const modelMap = new Map<string, ModelTokenData>();

  // Add existing state data to the map
  for (const data of state) {
    modelMap.set(data.model, { ...data });
  }

  // Merge update data with existing data
  for (const data of update) {
    const existing = modelMap.get(data.model);
    if (existing) {
      // Merge the metrics for the same model
      modelMap.set(data.model, {
        model: data.model,
        cacheCreationInputTokens:
          existing.cacheCreationInputTokens + data.cacheCreationInputTokens,
        cacheReadInputTokens:
          existing.cacheReadInputTokens + data.cacheReadInputTokens,
        inputTokens: existing.inputTokens + data.inputTokens,
        outputTokens: existing.outputTokens + data.outputTokens,
      });
    } else {
      // Add new model data
      modelMap.set(data.model, { ...data });
    }
  }

  // Convert map back to array
  return Array.from(modelMap.values());
}

/**
 * Orchestrator state annotation following LangGraph patterns
 * Includes message handling and orchestration state
 */
export const OrchestratorStateAnnotation = Annotation.Root({
  /**
   * Messages for LLM interactions
   */
  messages: Annotation<BaseMessage[]>({
    reducer: messagesStateReducer,
    default: () => [],
  }),

  /**
   * The task plan generated by the orchestrator
   */
  taskPlan: Annotation<TaskPlan | null>({
    reducer: (state, update) => update ?? state,
    default: () => null,
  }),

  /**
   * Current orchestration context and notes
   */
  orchestrationNotes: Annotation<string>({
    reducer: (state, update) => update ?? state,
    default: () => "",
  }),

  /**
   * Token usage data for cost tracking and caching
   */
  tokenData: Annotation<ModelTokenData[]>({
    reducer: tokenDataReducer,
    default: () => [],
  }),

  /**
   * Current active task ID being processed
   */
  activeTaskId: Annotation<string | null>({
    reducer: (state, update) => update ?? state,
    default: () => null,
  }),

  /**
   * Agent availability and workload tracking
   */
  agentWorkloads: Annotation<Record<string, number>>({
    reducer: (state, update) => ({ ...state, ...update }),
    default: () => ({}),
  }),

  /**
   * Execution metadata
   */
  executionMetadata: Annotation<Record<string, unknown>>({
    reducer: (state, update) => ({ ...state, ...update }),
    default: () => ({}),
  }),
});

/**
 * Type inference for the orchestrator state
 */
export type OrchestratorState = typeof OrchestratorStateAnnotation.State;

/**
 * Graph configuration schema following Open SWE patterns
 */
export const GraphConfigSchema = z.object({
  /**
   * The model name to use for planning tasks
   * @default "anthropic:claude-sonnet-4-0"
   */
  plannerModelName: z
    .string()
    .optional()
    .default("anthropic:claude-sonnet-4-0"),

  /**
   * Temperature for planner model
   * @default 0
   */
  plannerTemperature: z.number().optional().default(0),

  /**
   * The model name to use for coordination tasks
   * @default "anthropic:claude-sonnet-4-0"
   */
  coordinatorModelName: z
    .string()
    .optional()
    .default("anthropic:claude-sonnet-4-0"),

  /**
   * Temperature for coordinator model
   * @default 0
   */
  coordinatorTemperature: z.number().optional().default(0),

  /**
   * The model name to use for synthesis tasks
   * @default "anthropic:claude-sonnet-4-0"
   */
  synthesizerModelName: z
    .string()
    .optional()
    .default("anthropic:claude-sonnet-4-0"),

  /**
   * Temperature for synthesizer model
   * @default 0
   */
  synthesizerTemperature: z.number().optional().default(0),

  /**
   * The model name to use for optimization tasks
   * @default "anthropic:claude-3-5-haiku-latest"
   */
  optimizerModelName: z
    .string()
    .optional()
    .default("anthropic:claude-3-5-haiku-latest"),

  /**
   * Temperature for optimizer model
   * @default 0
   */
  optimizerTemperature: z.number().optional().default(0),

  /**
   * Maximum tokens to generate
   * @default 10000
   */
  maxTokens: z.number().optional().default(10000),

  /**
   * API key for OpenRouter
   */
  openRouterApiKey: z.string().optional(),
});

/**
 * Type for graph configuration
 */
export type GraphConfig = z.infer<typeof GraphConfigSchema>;
